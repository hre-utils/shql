= baSH Query Language (shql)
Marcus Aurelius <marcus [at] aurelius [dot] org>
:source-highlighter:     pygments
:pygments-style:         algol_nu
:pygments-linenums-mode: table
:toc:                    left
:toclevels:              3

JSON parsing & query language written entirely in Bash.

== Installation
Clone the repo.

== Invocation
[source]
----
usage:
   shql -q query_string [<file>]
   shql -f query_file [<file>]

Options:
   -h, --help        Print this message and exit
   -q, --query       Performs QUERY on input JSON
   -f, --query-file  Performs queries from a file on input JSON

Examples:
   Read data from a configuration file, update a value, then print to validate:
   $ shql -q '/.foo > update('bar'); / > print()' config.json

   Insert data into the 3rd index of an existing list:
   $ shql -q '/.bar > insert(3, "new list item")' config.json

   Read JSON from stdin, pretty print it back out:
   $ echo '{"this": "that"}' | shql -q '/ > print()'
----

== Operations
The structure of all queries is as follows:
----
LOCATION '>' OPERATION [';' LOCATION '>' OPERATION]*
----

All queries must start with a leading `/` to indicate the '`root`' of the data structure.
This can be subscripted using standard dict dotted notation (`/.foo`), or list subscription (`/[0]`).

Given the following dataset:

.input.json
[source,json]
----
{
   "foo": "bar",
   "baz": [
      "one",
      "two",
      "three"
   ]
}
----

To access the value of '`foo`' our query is: `/.foo`.
For the 1st element of '`baz`': `/.baz[0]`.

Multiple operations can be written on the same line, separating them with a semicolon.

[source]
----
/.foo > update('BAR'); / > print()
----


=== print()
==== Description
Recursively prints the data selected by the query.

==== Arguments
Print takes no arguments.

==== Example
.Print the whole dataset
[source]
----
/ > print()
----

.Print root -> baz -> [1]
[source]
----
/.baz[1] > print()
----

=== write()
==== Description
Dumps the data selected by the query to a text file.

==== Arguments
String file path relative to the current directory.

==== Example
.Dumps entire dataset to a file
[source]
----
/ > write('dataset.json')
----

=== insert()
==== Description
Inserts new JSON into a specified dict key, or into a list index.
If inserting into a list, values are shifted from the index up to make room.

==== Arguments
Takes an index, followed by valid JSON input.

When inserting into a list, the index must be an integer.
For a dict insertion, the index must be a string.

==== Example
.List insert
[source]
----
/.baz > insert(0, 'five'); /.baz > insert(1, ['a', 'new', 'list'])
----

.Dict insert
[source]
----
/.foo > insert('new', 'VALUE')
----

=== update()
==== Description
Inserts new JSON into a specified query location.
The existing node is recursively deleted prior to the new node is inserted in its place.

==== Arguments
JSON data.

==== Example
.Nuke root -> baz -> *, replace with 'BAZ'
[source]
----
/.baz > update('BAZ')
----

=== delete()
==== Description
Recursively deletes the data selected by the query.
Deleting the root node may make the database unusable (WORK IN PROGRESS).

==== Arguments
Delete takes no arguments.

==== Example
.Specific node deletion
[source]
----
/.baz[0] > delete()
----
