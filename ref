#!/bin/bash
#
# changelog
#  2021-07-24  :: Created
#
# desc :: starting with some real quick and dirty stuff here to see if this
#         is going to work at all--attempt is to make a basic, but featureful,
#         .json lexer & parser in bash.


INFILE="$1"
if [[ ! -e "$INFILE" ]] ; then
   echo "Missing input file"
   exit 1
fi


# For later, doing incremental backups on each change.
PROGDIR=$( cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd )
BACKUP1="${PROGDIR}/.backup1.json"
BACKUP2="${PROGDIR}/.backup2.json"
BACKUP3="${PROGDIR}/.backup3.json"


declare -a TOKENS=()
declare -i GLOBAL_TOKEN_NUMBER=0

declare -ag CHARRAY=()
declare -Ag CURSOR=(
   [lineno]=0
   [colno]=1
   [pos]=-1
   # Kinda dumb and hacky. Starting at (-1) so the first call to advance() will
   # increment by 1, thus reading the *next* character, the first.
)

declare -g CURRENT PEEK BUFFER


function Token {
   ttype="$1"

   if [[ -z "$ttype" ]] ; then
      echo "Missing \$ttype" ; exit 2
   fi

   # Make token. Add to list.
   tname="token_${GLOBAL_TOKEN_NUMBER}"
   TOKENS+=( $tname )

   declare -Ag $tname
   declare -n t=$tname

   # Data.
   t[type]="$ttype"
   t[data]="$BUFFER"

   # Meta information.
   t[lineno]=${CURSOR[lineno]}
   t[colno]=${CURSOR[colno]}
   t[pos]=${CURSOR[pos]}

   # Increment.
   ((GLOBAL_TOKEN_NUMBER++))

   # Pretty print?
   #echo "${t[type]} ${t[lineno]},${t[colno]} ${t[data]@Q}"
}


function advance {
   # Advance position in file.
   ((CURSOR[pos]++))

   CURRENT=
   PEEK=

   if [[ ${CURSOR[pos]} -lt ${#CHARRAY[@]} ]] ; then
      CURRENT=${CHARRAY[CURSOR[pos]]}
   fi

   if [[ ${CURSOR[pos]} -lt $((${#CHARRAY[@]}-1)) ]] ; then
      PEEK=${CHARRAY[CURSOR[pos]+1]}
   fi

   if [[ "$CURRENT" == $'\n' ]] ; then
      ((CURSOR[lineno]++))    # Increment line number.
      CURSOR[colno]=1         # Reset column position.
   fi
}


function comment {
   BUFFER="$CURRENT"

   while [[ -n $CURRENT ]] ; do
      [[ "$PEEK" =~ [$'\n'] ]] && break
      advance ; BUFFER+="$CURRENT"
   done

   # Create token.
   Token 'COMMENT'
}


function string {
   delim="$1"
   BUFFER=''

   while [[ -n $CURRENT ]] ; do
      [[ "$PEEK" =~ [${delim@Q}] ]] && break
      advance
      BUFFER+="$CURRENT"
   done

   # Skip final closing ('|").
   advance

   # Create token.
   Token 'STRING'
}


function munch {
   delim="$1"
   BUFFER="$CURRENT"

   while [[ -n $CURRENT ]] ; do
      echo "[[ ${PEEK@Q} =~ [${delim@Q}] ]]"
      [[ "${PEEK}" =~ [${delim@Q}] ]] && break
      advance ; BUFFER+="$CURRENT"
   done
}


function lex {
   # Fill into array, allows us to seek forwards & backwards.
   while read -rN1 c ; do
      CHARRAY+=( "$c" )
   done < "$INFILE"

   # Iterate over array of characters. Lex into tokens.
   while [[ ${CURSOR[pos]} -lt ${#CHARRAY[@]} ]] ; do
      advance
      [[ -z $CURRENT ]] && break

      # Skip comments.
      if [[ "$CURRENT" == '#' ]] ; then
         comment ; continue
      fi

      # Skip whitespace.
      [[ "$CURRENT" =~ [[:space:]] ]] && continue

      # Symbols.
      [[ "$CURRENT" == ':' ]] && Token 'COLON'     && continue
      [[ "$CURRENT" == '[' ]] && Token 'L_BRACKET' && continue
      [[ "$CURRENT" == ']' ]] && Token 'R_BRACKET' && continue
      [[ "$CURRENT" == '{' ]] && Token 'L_BRACE'   && continue
      [[ "$CURRENT" == '}' ]] && Token 'R_BRACE'   && continue

      # Strings.
      if [[ "$CURRENT" =~ [\"\'] ]] ; then
         string "$CURRENT" ; continue
      fi
   done
}


lex
