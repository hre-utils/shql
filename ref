#!/bin/bash
# changelog
#  2021-07-24  :: Created
#
# desc :: starting with some real quick and dirty stuff here to see if this
#         is going to work at all--attempt is to make a basic, but featureful,
#         .json lexer & parser in bash. It shall be .shon. Shell object
#         notation.
# todo :: 1) Change all CURRENT's to be the namerefs themselves, and give all
#            dicts a [name] prop to refer to themselves. Better than needing to
#            use a `declare -p`.
#         2) Could probably declare a LINE_BUFFER[], which holds the contents of
#            each line up to a $'\n', at which point it's cleared. Allow us to
#            not need to hold the entire contents of the file in yet another
#            array. Upon hitting an ERROR token, the message, along with the
#            original line, are saved to props in the object.
#         3) "Cache" each run, by dumping the generated AST to a file. Can parse
#            from the AST if there's a matching md5sum.

#══════════════════════════════════╡ GLOBAL ╞═══════════════════════════════════
# Color garbage.
rst=$(tput sgr0)                                   # Reset
bk="$(tput setaf 0)"                               # Black
rd="$(tput setaf 1)"  ;  brd="$(tput bold)${rd}"   # Red     ;  Bright Red
gr="$(tput setaf 2)"  ;  bgr="$(tput bold)${gr}"   # Green   ;  Bright Green
yl="$(tput setaf 3)"  ;  byl="$(tput bold)${yl}"   # Yellow  ;  Bright Yellow
bl="$(tput setaf 4)"  ;  bbl="$(tput bold)${bl}"   # Blue    ;  Bright Blue
mg="$(tput setaf 5)"  ;  bmg="$(tput bold)${mg}"   # Magenta ;  Bright Magenta
cy="$(tput setaf 6)"  ;  bcy="$(tput bold)${cy}"   # Cyan    ;  Bright Cyan
wh="$(tput setaf 7)"  ;  bwh="$(tput bold)${wh}"   # White   ;  Bright White

# HI LINK
HI_IDENT="${bcy}"
HI_SURROUND="${bk}"
HI_STRING="${rd}"
HI_COMMA="${bk}"


INFILE="$1"
if [[ ! -e "$INFILE" ]] ; then
   echo "Missing input file"
   exit 1
fi

# For printing better error output.
declare -a FILE_BY_LINES

# For later, doing incremental backups on each change.
PROGDIR=$( cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd )
BACKUP1="${PROGDIR}/.backup1.json"
BACKUP2="${PROGDIR}/.backup2.json"
BACKUP3="${PROGDIR}/.backup3.json"

# Hash for caching.
RUN_HASH=$( md5sum "$INFILE" | awk '{print $1}' )
HASHFILE="${PROGDIR}/cache/${RUN_HASH}"
mkdir -p "$(dirname "${HASHFILE}")"

#──────────────────────────────────( lexing )───────────────────────────────────
declare -a TOKENS=()
declare -i GLOBAL_TOKEN_NUMBER=0 IDX=0

declare -a CHARRAY=()
declare -A CURSOR=(
   [lineno]=1
   [colno]=0
   [pos]=-1
   # Kinda dumb and hacky. Starting at (-1) so the first call to advance() will
   # increment by 1, thus reading the *next* character, the first.
)

declare -A FREEZE
declare -- CURRENT PEEK BUFFER

#──────────────────────────────────( parsing )──────────────────────────────────
# Same dumb nonsense here as in 11k. Starting at -1 so initial advance is to 0.
declare -i tIDX=-1
declare -- TOKEN tNAME tPEEK1 tPEEK2
# tNAME is the tname of the current token.
# TOKEN is a nameref to the token itself.

# AST generation
declare -- AST_NODE
declare -i GLOBAL_AST_NUMBER=0

#──────────────────────────────────( output )───────────────────────────────────
declare -i INDNT_SPS=2     # How many spaces per level of indentation
declare -i INDNT_LVL=0     # Current level of indentation


#═══════════════════════════╡ PRINTING & DEBUGGING ╞════════════════════════════
declare -A colormap=(
   [DOT]="$yl"
   [COLON]="$wh"
   [COMMA]="$wh"
   [STRING]="$rd"
   [COMMENT]="$cy"
   [L_BRACE]="$wh"
   [R_BRACE]="$wh"
   [L_BRACKET]="$wh"
   [R_BRACKET]="$wh"
   [EOF]="$gr"
)

function print_tokens {
   for tname in "${TOKENS[@]}" ; do
      declare -n t="$tname"
      declare col="${colormap[${t[type]}]}"
      printf "${col}%-10s${rst}  ${bk}%-7s${rst}  ${col}${t[data]}${rst}\n" \
         ${t[type]} \
         "${t[lineno]}:${t[colno]}"
   done
}


function indent {
   printf -- "%$(( INDNT_LVL * INDNT_SPS ))s"  ''
}


#═══════════════════════════════════╡ LEXER ╞═══════════════════════════════════
function Token {
   ttype="$1"
   data="${2:-$BUFFER}"

   if [[ -z "$ttype" ]] ; then
      echo "Missing \$ttype" ; exit 2
   fi

   # Make token. Add to list.
   tname="token_${GLOBAL_TOKEN_NUMBER}"
   TOKENS+=( $tname )

   declare -Ag $tname
   declare -n t=$tname

   # Data.
   t[type]="$ttype"
   t[data]="$data"

   # Meta information.
   t[lineno]=${FREEZE[lineno]}
   t[colno]=${FREEZE[colno]}
   t[pos]=${FREEZE[pos]}

   # Increment.
   ((GLOBAL_TOKEN_NUMBER++))

   # TODO: Hitting an odd situation in which the first increment is returning a
   #       '1' status for some reason. Need to figure out why that is. Remove
   #       elements to narrow down. I don't think incrementing a number should
   #       return anything but '0'.
   return 0
}


function advance {
   # Advance position in file, and position in line.
   ((CURSOR[pos]++))
   ((CURSOR[colno]++))

   CURRENT=
   PEEK=

   if [[ ${CURSOR[pos]} -lt ${#CHARRAY[@]} ]] ; then
      CURRENT=${CHARRAY[CURSOR[pos]]}
   fi

   if [[ ${CURSOR[pos]} -lt $((${#CHARRAY[@]}-1)) ]] ; then
      PEEK=${CHARRAY[CURSOR[pos]+1]}
   fi

   if [[ "$CURRENT" == $'\n' ]] ; then
      ((CURSOR[lineno]++))    # Increment line number.
      CURSOR[colno]=0         # Reset column position.
   fi
}


function comment {
   while [[ -n $CURRENT ]] ; do
      [[ "$PEEK" =~ [$'\n'] ]] && break
      advance
   done
}


function string {
   delim="$1"
   declare -a buffer=()

   while [[ -n $CURRENT ]] ; do
      if [[ "$PEEK" =~ [$delim] ]] ; then
         if [[ "${buffer[-1]}" == '\\' ]] ; then
            unset buffer[-1]
         else
            break
         fi
      fi
      advance
      buffer+=( "$CURRENT" )
   done

   # Set global buffer to joined output of local buffer.
   # >>> BUFFER = ''.join(local_buffer)
   BUFFER=''
   for c in "${buffer[@]}" ; do
      BUFFER+="$c"
   done

   # Create token.
   Token 'STRING'

   # Skip final closing ('|").
   advance
}


function identifier {
   BUFFER="$CURRENT"

   while [[ -n $CURRENT ]] ; do
      [[ "${PEEK}" =~ [^[:alnum:]_] ]] && break
      advance ; BUFFER+="$CURRENT"
   done

   #Token 'IDENTIFIER'
   local loc="[${FREEZE[lineno]}:${FREEZE[colno]}]"
   Token 'ERROR'  "Syntax Error: $loc 'Identifier' not yet implemented."
}


function lex {
   # Fill into array, allows us to seek forwards & backwards.
   while read -rN1 c ; do
      CHARRAY+=( "$c" )
   done < "$INFILE"

   # TODO;XXX
   # Creating secondary line buffer to do better debug output printing.
   mapfile -td $'\n' FILE_BY_LINES < "$INFILE"

   # Iterate over array of characters. Lex into tokens.
   while [[ ${CURSOR[pos]} -lt ${#CHARRAY[@]} ]] ; do
      advance
      [[ -z $CURRENT ]] && break

      # "Freeze" the line number and cursor number, such that they're attached
      # to the *start* of a token, rather than the end.
      FREEZE[lineno]=${CURSOR[lineno]}
      FREEZE[colno]=${CURSOR[colno]}
      FREEZE[pos]=${CURSOR[pos]}

      # Skip comments.
      if [[ "$CURRENT" == '#' ]] ; then
         comment ; continue
      fi

      # Skip whitespace.
      [[ "$CURRENT" =~ [[:space:]] ]] && continue

      # Symbols.
      case "$CURRENT" in
         '.')  Token       'DOT' "$CURRENT" &&  continue ;;
         ':')  Token     'COLON' "$CURRENT" &&  continue ;;
         ',')  Token     'COMMA' "$CURRENT" &&  continue ;;
         '{')  Token   'L_BRACE' "$CURRENT" &&  continue ;;
         '}')  Token   'R_BRACE' "$CURRENT" &&  continue ;;
         '[')  Token 'L_BRACKET' "$CURRENT" &&  continue ;;
         ']')  Token 'R_BRACKET' "$CURRENT" &&  continue ;;
      esac

      # Strings.
      if [[ "$CURRENT" =~ [\"\'] ]] ; then
         string "$CURRENT" ; continue
      fi

      # Identifiers.
      if [[ "$CURRENT" =~ [[:alpha:]_] ]] ; then
         identifier ; continue
      fi

      # If none of the above, it's an invalid character.
      local loc="[${FREEZE[lineno]}:${FREEZE[colno]}]"
      Token 'ERROR'  "Syntax Error: $loc Invalid character ${CURRENT@Q}."
   done

   Token 'EOF' 'null'
}

#══════════════════════════════════╡ PARSER ╞═══════════════════════════════════
function raise_parse_error {
   local loc="[${TOKEN[lineno]}:${TOKEN[colno]}]"
   echo -n "Parse Error: ${loc} "
   echo -e "Expected ${byl}${@}${rst}, received ${TOKEN[type]}."

   exit -2
}


function raise_key_error {
   local loc="[${TOKEN[lineno]}:${TOKEN[colno]}]"
   echo -n "Key Error: ${loc} "
   echo -e "Key ${byl}${1@Q}${rst} not found."
}


function raise_duplicate_key_error {
   local loc="[${TOKEN[lineno]}:${TOKEN[colno]}]"
   echo -n "Warning: ${loc} "
   echo -e "Key ${byl}${1@Q}${rst} already used. Overwriting previous."
}


function t_advance {
   # Advance position in file, and position in line.
   ((tIDX++)) 

   TOKEN=
   tNAME=
   tPEEK1=
   tPEEK2=

   if [[ ${tIDX} -lt ${#TOKENS[@]} ]] ; then
      tNAME=${TOKENS[tIDX]}
      declare -gn TOKEN=${tNAME}
   fi

   # Lookahead +1.
   if [[ ${tIDX} -lt $((${#TOKENS[@]}-1)) ]] ; then
      declare t1=${TOKENS[tIDX+1]}
      declare -gn tPEEK1=$t1
   fi

   # Lookahead +2.
   if [[ ${tIDX} -lt $((${#TOKENS[@]}-2)) ]] ; then
      declare t2=${TOKENS[tIDX+2]}
      declare -gn tPEEK2=$t2
   fi
}


function mkString {
   ((GLOBAL_AST_NUMBER++))
   local node_name="_NODE_${GLOBAL_AST_NUMBER}"
   declare -g $node_name
   declare -g AST_NODE="$node_name"

   # DEBUG, print output.
   #declare -p ${node_name}
}


function mkList {
   ((GLOBAL_AST_NUMBER++))
   local node_name="_NODE_${GLOBAL_AST_NUMBER}"
   declare -ga $node_name
   declare -g AST_NODE="$node_name"

   # DEBUG, print output.
   #declare -p ${node_name}
}


function mkDictionary {
   ((GLOBAL_AST_NUMBER++))
   local node_name="_NODE_${GLOBAL_AST_NUMBER}"
   declare -gA $node_name
   declare -g AST_NODE="$node_name"

   # DEBUG, print output.
   #declare -p ${node_name}
}


function check_lex_errors {
   ERROR_FOUND=false

   # APPROACH #1.
   #
   #for tname in "${TOKENS[@]}" ; do
   #   declare -n t="$tname"
   #   if [[ ${t[type]} == 'ERROR' ]] ; then
   #      ERROR_FOUND=true

   #      error_line=${FILE_BY_LINES[t[lineno]-1]}
   #      # Just a bunch of stupid `sed` and color escape garbage.
   #      color_line=$(
   #         sed -E "s,(.{$((t[colno]-1))})(.)(.*),\1${rd}\2${rst}\3," \
   #         <<< "$error_line"
   #      )

   #      echo "${t[data]}"
   #      printf "${cy}%4d |${rst} ${color_line}\n" ${t[lineno]-1]}
   #   fi
   #done

   # APPROACH #2.
   for tname in "${TOKENS[@]}" ; do
      declare -n t="$tname"
      if [[ ${t[type]} == 'ERROR' ]] ; then
         ERROR_FOUND=true

         error_line=${FILE_BY_LINES[t[lineno]-1]}
         # Just a bunch of stupid `sed` and color escape garbage.
         color_line=$(
            sed -E "s,(.{$((t[colno]-1))})(.)(.*),\1${rd}\2${rst}\3," \
            <<< "$error_line"
         )

         msg_text="${t[data]}"
         msg_length=$(( ${#msg_text} + 2 ))

         error_pos=$(( t[colno] + 7 ))
         # Column # of the error, plus the leading "spacer" containing line
         # number, and the '|' separator.

         # Box drawing line characters that point to the offending character.
         pointer='' ; hzsep=''

         # The error is directly below the indicator, only need a pipe.
         if [[ ${msg_length} -eq ${error_pos} ]] ; then
            offset=$(( msg_length -1 ))
            pointer='│'
         # For errors that are in *front* of the initial indicator.
         elif [[ ${msg_length} -lt ${error_pos} ]] ; then
            offset=$(( msg_length -1 ))
            for i in $( seq $((error_pos - msg_length -1)) ) ; do
               hzsep+='─'
            done
            pointer="└${hzsep}┐"
         # For errors *behind* the indicator.
         elif [[ ${msg_length} -gt ${error_pos} ]] ; then
            offset=$(( error_pos -1 ))
            for i in $( seq $((msg_length - error_pos -1)) ) ; do
               hzsep+='─'
            done
            pointer="┌${hzsep}┘"
         fi

         # Print it!
         echo -e "${msg_text} ${cy}┐${rst}"
         printf "%${offset}s${cy}${pointer}${rst}\n"  ''
         printf "${cy}%4d |${rst} ${error_line}\n" ${t[lineno]-1]}
      fi
   done

   $ERROR_FOUND && exit -1
}


function munch {
   t_advance
   declare -a expected=( ${1//,/ } )

   local found=false
   for exp in "${expected[@]}" ; do
      if [[ ${TOKEN[type]} == $exp ]] ; then
         found=true ; break
      fi 
   done

   $found || raise_parse_error "${expected[@]}"
}


function parse {
   check_lex_errors

   grammar_data
   munch 'EOF'
}


#──────────────────────────────────( grammar )──────────────────────────────────
function grammar_data {
   munch 'STRING,L_BRACE,L_BRACKET'

   case ${TOKEN[type]} in
      'STRING')      grammar_string ;;
      'L_BRACE')     grammar_dict   ;;
      'L_BRACKET')   grammar_list   ;;
      *) raise_parse_error ;;
   esac
}


function grammar_string {
   mkString
   declare -- node_name=$AST_NODE
   declare -n s=$node_name

   s="${TOKEN[data]}"

   # Reset global AST pointer to this String node.
   AST_NODE=$node_name

   # DEBUG
   #echo "STRING(${AST_NODE} -> $s)"
}


function grammar_list {
   mkList
   declare -- node_name=$AST_NODE
   declare -n l=$node_name

   grammar_data
   l+=( ${AST_NODE} )

   while [[ ${tPEEK1[type]} == 'COMMA' ]] ; do
      munch 'COMMA'
      [[ ${tPEEK1[type]} == 'R_BRACKET' ]] && break
      grammar_data
      l+=( ${AST_NODE} )
   done
   
   munch 'R_BRACKET'

   # Reset global AST pointer to this List node.
   AST_NODE=$node_name

   # DEBUG
   #echo "$(declare -p l) -> LIST(${l[@]})"
}


function grammar_dict {
   mkDictionary
   declare -- node_name=$AST_NODE
   declare -n d=$node_name

   # Initial assignment.
   munch 'STRING' ; local key=${TOKEN[data]}
   munch 'COLON'
   grammar_data   ; d[$key]="$AST_NODE"

   while [[ ${tPEEK1[type]} == 'COMMA' ]] ; do
      munch 'COMMA'
      [[ ${tPEEK1[type]} == 'R_BRACE' ]] && break
      # Subsequent assignments.
      munch 'STRING'
      local key=${TOKEN[data]}

      if [[ -n "${d[$key]}" ]] ; then
         raise_duplicate_key_error "$key"
      fi

      munch 'COLON'
      grammar_data ; d[$key]="$AST_NODE"
   done

   munch 'R_BRACE'

   # Reset global AST pointer to this Dict node.
   AST_NODE=$node_name
}

#═══════════════════════════════════╡ CACHE ╞═══════════════════════════════════
function cache_ast {
   declare -i idx=1
   while [[ $(declare -p "_NODE_${idx}" 2>/dev/null) ]] ; do
      node_name="_NODE_${idx}"
      declare -p ${node_name}
      ((idx++))
   done > "$HASHFILE"
}


#════════════════════════════════╡ TREEWALKERS ╞════════════════════════════════
function get_type {
   declare t=$(declare -p "$1" | awk '{print $2}')

   case $t in
      '--')    echo 'string' ;;
      '-a')    echo 'list'   ;;
      '-A')    echo 'dict'   ;;
   esac
}

#───────────────────────────────( pretty print )────────────────────────────────
function pretty_print {
   print_type _NODE_1
}


function print_type {
   declare node_name="$1"
   declare node_type=$( get_type "$node_name" )

   case $node_type in
      'string')   pp_string "$node_name" ;;
      'list')     pp_list   "$node_name" ;;
      'dict')     pp_dict   "$node_name" ;;
   esac
}


function pp_string {
   declare node_name="$1"
   declare -n node="$node_name"
   echo "${HI_STRING}${node@Q}${rst}"
}


function pp_list {
   declare node_name="$1"
   declare -n node="$node_name"

   echo "${HI_SURROUND}[${rst}"
   ((INDNT_LVL++))
   
   for idx in "${!node[@]}" ; do
      declare child_name="${node[$idx]}"

      indent
      echo -n "$(print_type ${child_name})"

      if [[ $idx -lt $(( ${#node[@]} -1 )) ]] ; then
         echo "${HI_SURROUND},${rst} "
      else
         echo
      fi
   done

   ((INDNT_LVL--))
   indent ; echo "${HI_SURROUND}]${rst}"
}


function pp_dict {
   echo -e "${HI_SURROUND}{${rst}"
   ((INDNT_LVL++))

   declare node_name="$1"
   declare -n node="$node_name"

   declare -i num_keys_printed=0
   declare -i total_keys=${#node[@]}

   for child_key in "${!node[@]}" ; do
      ((num_keys_printed++))
      indent
      echo -n "${HI_IDENT}${child_key}${rst}${HI_SURROUND}:${rst} "
      echo -n "$(print_type ${node[$child_key]})"

      if [[ $num_keys_printed -lt $total_keys ]] ; then
         echo "${HI_COMMA},${rst} "
      else
         echo
      fi
   done

   ((INDNT_LVL--))
   indent ; echo "${HI_SURROUND}}${rst}"
}

#══════════════════════════════════╡ ENGAGE ╞═══════════════════════════════════
if [[ -e "$HASHFILE" ]] ; then
   echo -e "I've already parsed that one for you."
   echo -e "Guess I can waste my time doing it again...\n"
fi

lex
parse
cache_ast
pretty_print
